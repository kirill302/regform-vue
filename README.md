_рекомендую прасматривать данный файл через какое-то расширение для просмотра __markdown___

зачёрткнутый текст не несёт в себе никикой смысловой нагрузки! (~~yj tckb xnj? ye;yj ghjcnj hfcrkflre gjvtyznm~~)
# regForm

```c
npm install // установить пакеты
npm run serve // запустить локальный сервер
npm run build // скомпилировать приложение
npm run lint // запустить линтер
```

~~z yflt.cm ds gjyzkb ienre ghj scss~~

# DOCUMENTATION #
для вёрстки использовался `vue-bootstarp` + `scss`

для валидации использована библиотека `vuelidate` + `v-mask`

документация по `vue-bootstrap` здесь - https://bootstrap-vue.org/docs

докуметация по `scss` здесь - https://sass-scss.ru/documentation/

документация по `vuelidate` здесь - https://vuelidate.js.org/#getting-started

документация по `v-mask` здесь - https://www.npmjs.com/package/v-mask

*** 
## Один шаг регистрации - step 

Есть 7 компонентов `step` + `final`, при нажатии кнопок 'назад' и 'далее' генерируются события ` @prev` и `@next`
подписываемся на них, и увеличиваем переменную `currentStep`, в которой лежит текущий шаг, далее через `v-show` показываем наши компоненты (кроме 5 шага, там немного сложнее, но про него описано ниже)
```html

<step-0 @next="currentStep++" @prev="currentStep--" v-show="currentStep === 0"></step-0>
<step-1 @next="currentStep++" @prev="currentStep--" v-show="currentStep === 1"></step-1>
<step-2 @next="currentStep++" @prev="currentStep--" v-show="currentStep === 2"></step-2>
```

### Примечания по каждому шагу:
#### step0
есть переменная `agreeCheckBox` свзязанная с чекбоксом 'даю своё согласие', от этой переменной зависит `disabled` у кнопки 'далее' и красный цвет самого чекбокса

```html
<button :disabled="!agreeCheckBox">Далее</button>
```
#### step1
Маски (v-mask):
* Снилс - `###-###-###-##`
* Серия паспорта - `## ##`
* Номер паспорта - `######`
* Код подразделения - `###-###`

Важно, что минимально колиество символов учитывает как и символы введённые юзером так и символы из маски (пробел, дифис и тп)
```c
'###-###-###-##' //маска СНИЛСа
// В маске 14 символов, (11 введёт пользователь + 3 дифиса из маски) значит минимальное количество символов этом поле - 14 
```

#### Пляски с отчеством:
Итак, отчество обязательно, при нажатии на кнопку кнопку 'нет', вызывается метод `patronymicNone`, в нём, мы меняемя переменную `patronymicDisabled` либо на true либо на false, от этой перемееной зависит `disabled` поля 'отчество', + значение этого поля страновится 'нет'

<br>

#### Пляски с датой
В общем, пришлось писать нагромождения по требованию свыше (заказчика), при блюре (@blur) инпута с датой происходит слудеющее:
Мы берём дату из модели связанной с инпутом, после чего разрезаем с помощью `split('-')`, получаем массив элементов даты, далее, проверяем, чтобы кол-во символов года не было более 4, __если всё хорошо__, идём далее, а __если всё плохо__, и земля скоро развалится, мы с помощью `substr(0, 4)` вырезаем из строки года (`date[0]`) только первые 4 символа. После чего переварачиваем массив и преобразовываем его в строку с помощью `join()`
```js
dateBorn(e) { // вызываем этот метод при @blur инпута
  const strDate = e.target.value; // сохраняем значение в переменную data
  const date = strDate.split("-"); // разрезаем это значение
  if (date[0].length > 4) { // проверяем, если кол-во символов в году (date[0]) было более 4 то
    date[0] = date[0].substr(0, 4) // за избезанием конца света обрезаем год
  }
  this.passport.dateBorn = date.reverse().join("."); // переварачиваем наш массив, и превращаем его в строку
  e.target.setAttribute("type", "text"); // делаем инпут тектовым, чтобы потому-что
}
// есть идентичный метод dateIssue, только он для 'даты выдачи'
```
~~Z ghtlcnfdkz.? rfr cthm`pysq l;tyntkmvty? rjnjhsq pf,jnbncz j cdjtq cnfhjcnb? d gbl;frt? pf vfr,erjv? cblbn b gsnftncz j,vfyenm ufp ajyl? b gjcnfdbnm ct,t lfne hj;ltybz 2954384ujl? yj e ytuj ybxtuj yt gjkexbncz!!!!!!!~~

из-за особенностей стилей бутстрапа, чтобы всё отображалось адекатно, я  выдаю полю 'кем выдан', класс 'order-5' только при `pageWidth < 768px`
```html
<div :class="{'order-5': pageWidth < 768}" ></div>
```
#### step2
Для того, чтобы кнопка далее стала активной, ножно чтобы стояла кнопка `Являюсь налоговым резидентом...` + был включен чекбокс `Подтверждаю, что не являюсь...`
```html
<button :disabled="notInn || !confirm">далее</button> <!--notInn - переменная, которая true если пользователь нажал отсутвие инн рф, и false, если являюсь резидентом рф-->
```

Есть переменная `INNplaceholder`, в которой в зависимости от ширины окна меняется значение, это нужно, чтобы в мобилках в инпут вставлять более короткий `placeholder`

#### step4
!!!. q - __question__ (вопрос)
имеем 5 переменных `q1`, `q2`, `q3`, `q4`, `q5`, значение из которых соответсвует какому-либо вопросу.
при нажати на радио кнопку `нет`, соответсвующая `q` становится `false`, а при нажатии `да` - `true`, эти переменные нужны для блокировки кнопки `далее`, кнопка ативна только тогда, когда на всех вопросах стоит `нет`

```html
<button :disabled="q1 || q2 || q3 || q4 || q5">Далее</button>
```

#### step5 
__Для того, чтобы при открытии данного компонента сразу же запускался таймер, и чтобы он не обновлялся, при переходе на предыдущие и последующие шаги, он встраивается несколько иначе:__
при нажатии на кнопку 'далее' в 4 шаге, мы вызываем метод `nextStep5`
```html
<step-4 @next="nextStep5"></step-4>
```
этот метод увеличивает `currentStep` и меняет переменную `step5` на `true`
В родительском компоненте формы (в нашем случае `App.vue`), есть переменная `step5`, которая хранит булевое значение, обозначающее был ли открыт 5 шаг, и если он был открыт, то через `v-if`, мы его монтируем в DOM, и в хуке `mounted` (непосредственно внутри самого `step5`) запускаем таймер, далее, наш комонент будет скрываться через `v-show`. Это нужно для того, чтобы использовать хук `mounted` для запуска таймера, после открытия 5 шага, т.к он срабатывает, при встраивании компонента в DOM (в нашем случае через `v-if`)
__функцианал таймера__
* переменная `telTimer` - текущее значение таймера для повторной отправки кода.
* переменная `emailTimer` - то же самое, только для Eamil.
* переменная `againTelCode` - по дефолту false, но как только пользователь нажимает 'отправить код повторно', она становиться true.
* переменная `againEmailCode` - то же самое, только для Email .
* метод `startTelTimer` - запускает setInterval, который каждую секунду уменьшает 'telTimer'.
* метод `startEmailTimer` - то же самое, только для Eamil.

* метод `sendTelCode` - вызывается при нажатии кнопки 'отправить код', 
  ```js
  sendTelCode() {
    this.againTelCode = true; 
    this.telTimer = 3; // сюда количесво секунд, для обратного отчёта
    this.startTelTimer() // запускаем таймер

    // здесь я так понимаю будет функция, для отправки sms
  },
  ```
* метод `sendEmailCode` - то же самое, только для Email

* переменная `upadateTelInput` - менятеся на `true`, когда юзер нажимает на изменить телефон, от этой переменной зависит состояние инпута, для изменения телефона
  ```html
  <v-input :disabled="!upadateTelInput"> <!-- прокидывайте в этот инпут в value предыдущий, указанный пользователем телефон-->
  ```
* переменная `upadateEmailInput` - ну вы поняли крч

__валидация sms/email кодов__
переменные:
* `disabledTelBtn` и `disabledEmailBtn` - отвечают за блокировку кнопки 'далее'
* `confirmTelCode` и `confirmEmailCode` - изначально `false`, после нажатия на кнопку 'подтверждаю' она станет `true`
* `telCode` - в эту переменную записываем сам телефонный код
* `emailCode` - то же самое, только для Email
* `telInut` и `emailInput` - связаны через `v-model` с полями для ввёдения кодов
* `codeMask` - храним маску кода (по синтаксису библиотеки v-mask)

методы:
* `trackTelInput` и `trackEamilInput` - данные методы вызываются при изменении инпутов, следят за тем, чтобы кол-во символов введённого пользователем кода было равно колву символов маски (`this.codeMask`), после этого, сравнивают то, что ввёл юзер и код в переменной `telCode`, __если всё хорошо__, то разблокируем кнопку, убераем красс `unvalide` у инпута, убираем фокус, и делаем плейсхолдер `ввести код`. 
__Если всё плохо__ и скоро начнётся 3 мировая война, то блокируем кнопку, удаляем то, что ввёл пользователь, добавляем полю класс `unvalide`, и делаем плейсхолдер `введён некоррекный бла бла бла`

~~lkz nt[ e rjuj ytne htlfrnjhf rjlf d ujkjdt~~
```js 
trackTelInput() {
  const input = this.$refs.telInput.$el; // по референсу находим соответсвующий инпут
  if (this.telInut.length === this.codeMask.length) { // сравниваем кол-во символов введённого пользователем кода с кол-вом символов маски
    if (this.telInut === this.telCode) { // всё хорошо, код пользователя равен нашему коду  =====================================
      this.disabledTelBtn = false; // расдизабливаем кнопку
      input.classList.remove("unvalide"); // убираем класс unvalide
      input.placeholder = "Ввести SMS-код"; // меняем плейсхолдер

    } else { // всё плохо, мы скоро все умрём ==============================================
      this.disabledTelBtn = true; // отключаем кнопку
      this.telInut = ""; // обнуляем значение связанной с инпутом модели
      input.classList.add("unvalide"); // добовляем класс unvalide
      input.blur(); // снимаем фокус
      input.placeholder = "Введен некорректный SMS-код"; // меняем placeholder
    }
  } else {
    this.disabledTelBtn = true; // пока количесво символов не правильное, кнопка отключается
  }
}
```
когда мы нажмём на кнопку 'подтверждаю', переменная `confirmTelCode` станет тру, и мы заблокируем инпут кнопку и кнопку 'отправить код повторно' на веки вечные (то же самое и с Email)

ну и после прохождения 5 круга ~~flf~~ регитсраци, подтверждения почты и телефона, разблокиравается кнопка 'далее'
#### step6

на каждой радио кнопке, висит обработчик, которые присваевает в `conditionArray` нужную матрицу
```html
<input @change="conditionArray = conditions1Array"/>
```
```js
data() {
  return {
    conditionArray: [], //из этого массива данные вставляются в html
    conditions1Array: [
      [0.9, 1, 1, 1], 
      [0.5, 0.5, 0.5, 1],
    ],
    conditionsArray1: [
      [0.9, 1, 1, 1],
      [0.5, 0.7, 0.9, 1],
    ],
    conditionsArray2: [
      [0.95, 1, 1, 1],
      [0.7, 0.9, 1, 1],
    ]
    };
  },
  beforeMount() {
    this.conditionArray = this.conditions1Array; // здесь мы присваемаем матрицу, которая будет отображаться по дефолту
  },
```
в таблицу свставляются данные из `conditionArray`: 
```js
conditionArray[0][0] // перый элемент первой сточки
conditionArray[1][3] // третий элемент второй сточки
```

#### step7 
таймер + валидация кода реализованная тк же, как и в пятом шаге

__В дизайне, при адаптиве этот блок разделяется на 2 подшага, реализовано это так:__
есть переменная `visibleBlock`, в которой храниться номер показываемого блока (1 или 2)
в зависимости от висиблБлок к корневому элементу шага, добавляется класс (visible-1 или visible-2)
```html
<div :class="{ 'visible-1': visibleBlock === 1, 'visible-2': visibleBlock === 2 }" ></div>
```
и в зависимости от этого класса, мы через стили решаем, какой блок показывать, а какой нет
```scss
@media (max-width: 768px) {
  .step-7.visible-1 { // когда выдан класс visible-1
    .from-reg__col2 {
      display: none !important; // скрываем 1 блок
    }
    .from-reg__col1 {
      display: block !important; // показываем 2 блок
    }
  }
  .step-7.visible-2 { // когда выдан класс visible-1
    .from-reg__col2 {
      display: block !important; // показываем 2 блок
    }
    .from-reg__col1 {
      display: none !important; // скрываем 1 блок
    }
  }
}


```

## Компоненты:

* `<form-header>` - шапка формы
* `<form-footer>` - футер формы
***
### `<step-30-70>` `<step-50-50>` `<step-100>`
В дизайне пресованы шаги двух типов:
* 2 колонки, одна 30%, другая 70%, это `<step-30-70>`
* 2 колонки, одна 50% на 50%, это `<step-50-50>`
* 1 колонка 100%, это `<step-100>`

Эти компонетны идентичны, за исключением размеров колонок

Имеют 2 пропса (для отображения 1/7):
* `stepNum` - номер этого шага
* `amountSteps` - количество шагов

Имеют 7 слотов: 
* `v-slot:title` - заголовок шага
* `v-slot:col1-content` - контент 1 колонки
* `v-slot:col2-content` - контент 2 колонки
* `v-slot:button-prev` - кнопка 'вперёд' (в этот слот помещаем кнопку)
* `v-slot:button-next` - кнопка 'назад' (в этот слот помещаем кнопку)

``` html
<step-30-70 :stepNum="намерЭтогоШага" :amountSteps="количествоШагов" v-show="currentStep === 1">
  <template v-slot:title>заголовок</template>

  <template v-slot:col1-content>контент 1 колонки</template>
  <template v-slot:col2-content>контент 2 колонки</template>

  <template v-slot:button-prev>
    <button>назад</button>
  </template>
  <template v-slot:button-next>
    <button>вперёд</button>
  </template>
</step-30-70>
```

***
__у всех кастомных инпутов работает v-model__
#### `<v-input>`
просто инпут
имеет класс `unvalide`, что показывает, что инпут не прошел валидацию

можно использовать класс `form-reg__input` вместо компонента

#### `<autocomplete-Input>`
инпут с авто заполнением
имеет пропсы
* `autocompleteArray` - массив значений для автокомплита
* `placeholder`
* `disabled` - тип булеан
* `tabIndex` 

Коротко о том, как работает этот инпут:
Мы получаем пропсом массив `autocompleteArray`, далее 
В `mounted` присваиваем его в массив `completeArray` (из-за того, что пропсы изменять нельзя). 
Затем через `v-for` на основе этого массива выводим список из элементов `button.autocomplete__item`. 
При изменении инпута, вызываем метод `apdateInput`, который фильтрует `completeArray`, удаляя все элементы, которые не содержат вы себе value инпута. 
При фокусе инпута и начале ввода, мы показываем наш список, который реактивно фильтруется. 
При нажатии на какую-то подсказку, мы устанавливаем значение нажатой подсказки в `InputValue`, с которой через `v-model` связано поле. Далее в `Watch` мы наблюдаем изменение `InputValue`, и на каждое изменение делаем `$emit`
```js
  watch: {
    InputValue() {
      this.$emit("input", this.InputValue);
    }
  }
```


#### `<v-select>`
кастомный выпадающий список, имеет пропс `:options`,
в который передаем массив объектов, с полем `text` и `id` (значением по умолчанию будет являтся 1 элмент массива)

```html
<v-select :options="optionsArray"></v-select>
```
```js
optionsArray: [
  {text: 'option1', id: 0},
  {text: 'option2', id: 1},
  {text: 'option3', id: 2}
],
```
***
#### `<custom-input>`
!!! . Все ипнуты стилзованы с помощью svg изобращений из папки assets/images

Этот комнонент предназначен для стилизованных радио кнопок и чекбоксов, чтобы его использовать, нужно положить внутрь него сам инпут с атрибутом type, и в зависимости от типа, применятся определённые стили. Это сделано для того, чтобы иметь прямой доступ к самому инпуту (для валидации, v-model, и тп.)

Инпуты имеют класс `unvalide`, что говорит о том, что инпут не прошел валидацию
```html
<custom-input> <!--стилизованный чекбокс-->
  <input type="checkbox"/>
</custom-input>

<custom-input> <!--стилизованная радио кнопка-->
  <input type="radio" />
</custom-input>

<custom-input> <!--чекбокс не прошел валидацию-->
  <input type="checkbox" class="unvalide"/>
</custom-input>

<custom-input> <!--радио кнопка не прошла валидацию-->
  <input type="radio" class="unvalide"/>
</custom-input>
```
***
#### `<v-modal>`
!!!. НЕ ПУТАТЬ С  `v-model`

Модальное окно
Имеет пропс `visible`, в который передаем переменную, где храниться булевое значение, 
* `true` - модалка открыта
* `false` - закрыта

При нажатии на крестик, у компонента генерируется событие `hide`, подписываемся на него `@hide=''`, и передаем функцию, для закрытия модалки (в этой функции меняем переменную, которую передавали в пропс `:visible`)

Компонент имеет 2 слота, `title` и `text`, для заголовка и текста соответсвенно
``` html
<v-modal :visible="modalVisible" @hide="modalHide">
  <template v-slot:title>Заголовок</template> 
  <template v-slot:text>Текст</template>
</v-modal>
```

# Примечания по вёрстке:
***
Я дополнил классы бутстраппа несколькими своими
* `text-opacity` - текст становится прозрачным на 70% (rgba(0, 0, 0, 0.5))
* `text-red` - текст становится красным (`#DE231B`)
* `text-md-opacity` - та же прозрачность, но с бреёкпоинтом (> 786px)
* `fz-md-12px` - font-size: 12px при >768px
* `me-10px` - margin-right: 10px
* `lh-18px` - line-height: 18px
* `fz-14-12` - если ширина окна больше 768px - font-size: 14px, если меньше, то 12px
* `mb-30-20px` - при ширине более 768px, margin-bottom: 30px, менее: 20px
* `mb-30-20-10px` - то же самое, только при ширине менее 576px будет margin-bottom:10px
* `mb-40-30px` - то же самое
* `mb-30-15px` - то же самое
* `pt-2px` - padding-top:2px
* `me-5px` - margin-right: 5px
***
1. есть отдельный компонент `<v-button>`, в котором описаны стили для кнопки, но я использовал только класс `.v-button` из этого компонента

2. Есть компонент `v-link`, там так же описан класс `.v-link`, и использовал ссылку и как компонент, и как обычный класс, в зависимости от ситуации

3. Большинство стилей для компонентов `step30-70`, `step50-50` и `step100` написаны в компоненте `step30-70`

4. Все компоненты из папки `@/components` зарегистрированы глобально, кроме `form-footer` и `form-header`

5. В компоненте `v-input` описан класс `.form-reg__input`, на основе этого класса работает и инпут с автокомплитом
(`autocomplete-Input`), так же данный класс можно использовать без компонента.



~~rjulf , ds pyfkb rfr e;fcyj njvbnmcz ;f;lj. k.,db? gskfnm b hfpevjv dct xfcnyj cvbhznm djkytybt d rhjdb~~
